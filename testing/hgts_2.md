2장. 테스트 소프트웨어 엔지니어

기능코드를 작성 시에는 창조적인 마음가짐, 사용자, 유스케이스, 작업 흐름을 염두에 둬야 하며, 테스트 코드의 경우에는 파괴적인 마음가짐을 가지고 사용자와 작업 흐름을 방해하는 방식으로 코드를 작성해야 한다.

- SWE
  - 기능 개발자. 고객에게 전달될 컴포넌트 개발
  - 기능 코드와 단위 테스트 코드 작성
- SET
  - 테스트 개발자
  - SWE를 도와 단위 테스트의 일부 작성하는데 도와줌
  - SWE가 중소형 테스트를 작성하는데 도움이 되는 좀 더 큰 테스트 프레임워크 작성
- TE
  - 사용자 개발자. 사용자 관점에서 품질 측정
  - 개발 측면 : 사용자 시나리오에 대한 자동화 구축
  - 제품 측면: 제품 전체를 측정하고 다른 역할의 엔지니어들이 수행한 테스팅 활동들이 어떻게 조화롭게 작용했는지 효과를 측정

# SET에 대한 이야기

## 개발과 테스트 작업 흐름

SET와 SWE는 새로운 제품이나 서비스의 개발에 있어 매우 긴밀한 관계를 형성하고, 실제로 작업하는 많은 부분이 서로 겹친다.

테스팅은 엔지니어링 팀 전체의 몫이기 때문에.

### 공유 코드

대부분의 구글 코드는 하나의 저장소(repository)와 공통 툴 체인을 통해 공유된다. 빌드와 릴리스 하려면 이러한 툴과 저장소를 사용해야 한다.

**모든 구글 엔지니어는 역할에 관계없이 이런 환경을 상세히 알아야하고, 팀 내에서 누구의 도움도 없이 새로운 코드를 체크인하거나 테스트를 제출하고 실행하고, 빌드를 런칭하는 작업을 수행할 수 있어야 한다.**

어떠한 소스코드든지 그것을 보길 원하는 모든 엔지니어는 이용할 수 있다!

이런 공유 코드는 구글의 제품 인프라스트럭처에서 공유 라이브러리들로 작업하기 때문에 높은 신뢰도를 갖고 동작하고, 프로젝트가 완성되는 속도 역시 더 빨라지고 결함 발생률을 줄인다.

- 프로젝트에 특화된 요구를 충족시키기 위한 목적 외에는 기존 라이브러리 재사용
- 공유 코드는 쓰기 쉬운 곳에 위치해야 하며 가독성이 좋아야 한다. 모든 코드는 미래에 누군가가 읽고 수정할 것을 대비해서 작성돼야 한다.
- 공유코드는 가능한한 재사용 가능하고 스스로 모든 내용을 담고 있어야 한다. 재사용의 중요성!
- 의존성이 드러나야 한다. 프로젝트 변경에 의해 공유 코드의 의존성에 영향이 있다는 걸 모르면 수정 굉장히 어려움
- 좀 더 나은 방법을 제안한 엔지니어는 기존 모든 라이브러리에 대해 리팩토링을 하고 연관된 프로젝트들이 새로운 라이브러리를 사용하게 도와야 한다.
- 진지하게 코드 리뷰 진행. 특히 가독성 관점에서 모든 코드를 리뷰해야 한다. 코딩 스타일 가이드라인 준수!
- 공유 저장소에 있는 코드는 테스팅에 대해 더 높은 기준을 적용한다.

### 플랫폼

플랫폼 의존성은 최소화해야 한다. 플랫폼 의존성이 있는 모든 코드는 플랫폼의 최하위 레벨에 라이브러리 형태로 들어감

구글에서는 각 프로그래밍 언어당 단 하나의 컴파일러만 사용하며, 하나의 리눅스 배포판에 대해 지속적으로 테스트하고 관리한다.

통합된 빌드 시스템 -> 단일 플랫폼 단일 저장소 -> 공유 저장소 내의 작업 단순화

아래는 빌드 전체 흐름

1. 하나 또는 그 이상의 소스 파일에서 서비스에 대한 클래스 또는 함수를 작성하고 모든 코드가 컴파일되게 한다.
2. 새로운 서비스에 대한 라이브러리 빌드 타겟을 식별한다.
3. 라이브러리를 임포트하는 단위 테스트를 작성하고, 의존성이 큰 부분에 대해서는 mock을 만들고, 가장 흥미로운 값을 입력으로 주어, 가장 관심가능 코드 경로를 수행한다.
4. 단위 테스트에 대해 테스트용 타겟을 빌드한다.
5. 테스트 타겟을 빌드하고 수행한다. 모든 테스트를 통과할 때까지 필요한 변경을 한다.
6. 코드 스타일 가이드 규약과 문제 검사하는 데 필요한 정적 분석 툴을 수행한다.
7. 코드 리뷰에 대한 결과 코드를 보내고 리뷰 결과에 따라 코드 변경, 모든 단위 테스트를 다시 수행한다.

## 프로젝트의 초기 단계

구글 20% 활동: 4일은 돈 버는 일을 하고 1일은 혁신을 하라는 데서 나온 20%의 활동들이다. 비공식 프로젝트를 만들다가 공식 서비스가 된다던가, 자기 팀이 아닌 다른 팀 일을 해보는 등

20% 단계에서는 테스팅 자원을 가질 수 없다. 완벽한 제품의 컨셉을 갖고 가능성을 타진하기도 전에 품질에 초점을 두게 되면 우선순위를 거꾸로 작업하는 꼴이 된다. 어차피 나중에 다시 설계되기 때문에.

하지만 반대로 너무 오래 테스트하지 않으면 testability를 줄이는 설계 결정들을 되돌리기 어려워진다. 자동화도 어렵고 테스트 툴도 어렵고. 품질에 대한 부담 때문에 재작업 들어가고 제품 출시가 수년간 늦춰질 수도 있다.

구글의 프로세스는 비공식적인 결과물이나 혁신 위주의 프로젝트 생성에 더 중점을 둔다. 테스터는 프로젝트 초기에는 관여하지 않지만, 프로젝트가 실체화되면 어떻게 수행할 것인지에 대해 많은 영향력을 갖게 된다.

## 설계문서

### 설계 문서 리뷰 가이드

- 완전성(Completeness)
  - 불완전한 부분, 특별한 지식을 요구하는 부분, 새로운 팀 멤버가 알아야할 부분을 식별
  - 좀 더 상세하게 적도록
  - 부족한 부분을 채울 수 있는 다른 문서와 링크
- 정확성(Correctness)
  - 문법 철자 마침표 실수 찾기. 엉성함에 대한 선례를 남기지 말아라
- 일관성(Consistency)
  - 문서와 다이어그램, 문서와 문서 간 일치하도록 하기
- 설계(Design)
  - 현재 가용할 수 있는 자원으로 끝낼 수 있는가?
  - 어떤 인프라스트럭처 위에서 가능한가?
  - 제안된 설계를 지원할 수 있는 인프라스트럭처가 사용 가능한가?
  - 설계가 너무 복잡하지 않은가? 단순화시킬 수 있는가?
  - 너무 단순한가? 설계의 어떤 부분의 설명이 부족한가?
- 인터페이스(Interfaces)와 프로토콜(protocols)
  - 사용할 프로토콜에 대해 명확하게 식별돼 있는가?
  - 인터페이스와 프로토콜이 완벽하게 설명되어 있는가?
  - 구글의 다른 제품에 공통적으로 적용하는 내용이 있는가?
  - 개발자가 프로토콜 버퍼를 정의하게 할 수 있는가? (프로토콜 버퍼는 이후에 다룬다 함)
- 테스팅(Testing)
  - 문서에 기술된 시스템을 어떻게 테스트하는가?
  - 시스템을 테스트하기 위해 선행돼야할 내용, 개발자가 설계 문서에 추가해야 하는 정보들 추정

## 인터페이스와 프로토콜

프로토콜 버퍼: XML 같은데 더 작고 빠르고 쉽다. 데이터가 어떻게 구조화되는지 정의. 오픈소스로 공개됨

초기 통합 테스트를 가능하게 하기 위해 각 컴포넌트의 의존성이 있는 곳에 mock과 fake를 작성한다. 코드 개발하는 동안에 계속 이용가능하고 테스팅하기도 편함.

## 자동화 계획

자동화 활동이 확대될수록 유지 보수는 힘들어지고, 시스템이 발전할 수록 테스트는 깨지기 쉬워진다. 처음부터 끝까지 자동화를 하는 건 제품 설계에 경직성을 가져다준다.

(테스트 전 과정이 시스템의 특정 형태에 맞춰서 자동화되어버려서, 조금만 삐끗나도 자동화 테스트가 안 돌아가고 테스트에 맞춰서 제품 설계를 유지하는 그런 상황을 이야기하는 듯)

**더 작고 좀 더 특별한 목적을 갖는 자동화 테스트일 수록 유용하다!**

1. 에러가 발생할 가능성 있는 인터페이스 분리하기, mock과 fake를 만들어 의존성을 가진 인터페이스들을 제어하기, 좋은 테스트 커버리지 확보
2. 가벼운 자동화 프레임워크를 만들어 mock 시스템을 빌드하고 수행

이렇게 하면 어떤 SWE든 mock 인터페이스를 사용해서 자신만의 빌드를 만들고 테스트할 수 있다. 잘 테스트된 코드만 메인 코드베이스에 적용하도록

(Jenkins에서 빌드와 테스트 조건 만들었던 것과 비슷한 느낌?)

## 테스트 가능성 (Testability)

단위 테스트에 더 적합하게 프로그램 구조와 코딩 스타일을 추천하고, 개발자 스스로 테스트를 작성할 수 있게 프레임워크를 작성한다.

코드 리뷰 중심의 개발 프로세스. 코드 작성보다 코드 리뷰가 훨씬 더 가치가 있다.

오픈소스 커뮤니티의 '커미터(Committer)': 신뢰할만한 개발자임을 증명할 수 있는 사람들만 커밋할 수 있다.

구글에서는 모두가 커미터지만, 인증된 커미터와 신입 개발자를 구분하기 위해 가독성(readability)라는 개념을 사용한다.

코드 작성이 끝나면 Change list, 줄여서 CL이라고 부르고 몬드리안이라는 툴에 서브밋한다. 몬드리안은 인증된 SWE 또는 SET에게 코드를 보낸다. 큰 CL은 리뷰어의 지시에 따라 작은 CL로 분할된다. 동료들로부터 가독성 지적을 받으면서 좋은 CL 쓰는 법을 배우는 것이다.

(주니어가 바로 커밋하는 게 아니라 pull request를 보내는 거랑 비슷한 개념?)

CL이 리뷰어에게 전달되기 전에 수행하는 몇 가지 자동화된 검사가 있다. 구글 코딩 스타일 가이드를 준수하고, CL 관련된 기존 테스트 전부가 성공했는지 확인하는 작업

**코드 작성 뿐만 아니라 작성 후 리뷰어의 지적에 따라 발전시키고 좋은 코딩 습관 만드는 자세도 중요하구나!**

## SET 작업 흐름: 예제 (중요!!!)

HTML 폼에서 URL과 코멘트를 받아 HTTP GET 요청을 구글 서버에 보내는 예제

```
GET /addurl?url=http://www.foo.com&comment=Foo+comment HTTP/1.1
```

서버 측은 2개의 부분으로 나눠져 있다.

- AddUrlFronted: HTTP 요청 파싱하고 검증
- AddUrlService: 백엔드 서비스. Fronted에서 요청을 받아 에러를 검사하고 구글의 빅테이블, 구글 파일 시스템과 상호작용

### 프로토콜 정의

구글 프로토콜 버퍼 명세 언어를 이용해서 다음과 같이 AddUrlService 프로토콜을 정의한다.

depot/addurl/addurl.proto

```
message AddUrlRequest {
  required string url = 1;      // 사용자가 입력한 URL
  optional string comment = 2;  // 사용자가 작성한 코멘트
}

message AddUrlReply {
  // 에러가 발생한 경우, 에러 코드
  optional int32 error_code = 1;
  // 에러가 발생한 경우, 에러 메시지
  optional string error_details = 2;
}

service AddUrlService {
  // 인덱스에 제출할 URL 수락
  // RPC, Remote Procedure Call, 원격 프로시저 호출
  rpc AddUrl (AddUrlRequest) returns (AddUrlReply) {
    option deadline = 10.0; // 클라이언트가 10초 내에 응답 못 받으면 타임아웃
  }
}
```

required는 필수 입력값, optional은 선택 입력 값

AddUrlRequest는 사용자가 보내는 정보고, AddUrlReply는 서버가 사용자에게 보내는 정보다.

에러가 없는 일반적인 상황에서는 AddUrlReply를 비움 -> 데이터 전송량을 최소화 -> 빠르게 동작

**일반적인 상황에서는 빠르게 동작하게 만들어라. 이것이 구글의 규약이다.**

`url = 1` 왜 =1이 붙나? 호환성을 위해서.

만약 나중에  url 필드의 이름을 uri로 바꾸고 싶다면 `uri = 1`로 변경하면 구 버전과 신 버전 사이에 호환성을 유지한다. (숫자와 타입이 동일해야 함)

이렇게 addurl.proto 파일을 작성한 뒤 빌드 규칙을 생성한다.

depot/addurl/BUILD

```
proto_library(name="addurl", srcs=["addurl.proto"])
```

빌드 시스템 호출하면 프로토콜 버퍼 컴파일러에 의해 addurl.proto에 있는 아이템들을 정의한 C++ 소스파일이 생성되고 addurl C++ 라이브러리로 컴파일 된다. addurl.ph.h와 addurl.pb.cc 파일이 생성된다. 이슈가 있다면 개발자가 이슈 수정.

### 프론트엔드 코드 작성

addurl_frontend.h에 AddUrlFrontend 클래스를 선언하고, addurl_frontend.cc에 클래스 로직을 코드로 작성한다. (코드 생략)

이제 작성한 addurl_frontend를 빌드 파일에 추가한다.

depot/addurl/BUILD

```
# 기존 proto_library 부분 ~

# 신규
cc_library(name="addurl_frontend",
            srcs=["addurl_forntend.cc"],
            deps=[~]
          )
```

다시 빌드하고 에러 있으면 수정.

### 프론트엔드 단위테스트 작성

이제 AddUrlFrontend에 대한 단위테스트를 작성한다. addurl_frontend_test.cc에 작성한다.

AddUrlService 백엔드에 대한 페이크를 정의해 테스트한다. 테스트할 때는 AddUrlFrontend의 생성자에 페이크를 넘기고, 실제 작동할 때는 진짜 AddUrlService 객체를 넘기는 방식으로.

이렇게 하면 AddUrlFrontend 객체의 코드는 변경하지 않고 테스트도 할 수 있고 실제 빌드에 쓸 수도 있다.

(스프링에서 배운 의존성 주입 개념을 테스트에 활용할 수도 있구나)

모르는 용어들: 애자일 테스트? mock과 fake의 차이점?

이제 빌드 정의를 업데이트해서 addurl_frontend_test를 추가한다.

```
# 기존 부분들

# 신규:
cc_test(name="addurl_frontend_test",
        size="small",
        srcs=["addurl_forntend_test.cc"],
        deps=[~])
```

다시 빌드하고 에러 수정 테스트 수정. 모든 테스트 케이스를 추가할 때까지 반복한다.

### CL 만들기, 버전컨트롤 시스템에 반영

모든 테스트케이스가 성공했다면 지금까지 작성한 모든 파일들을 포함한 CL을 생성하고, 서브밋 전에 한 번 더 검토해서 고치고, CL을 보낸 뒤 리뷰 피드백을 기다린다.

```
$ create_cl BUILD \
          addurl.proto \
          addurl_frontend.h \
          addurl_frontend.cc \
          addurl_frontend_test.cc

$ mail_cl -m reviewer@google.com
```

기다리는 동안 AddUrlService 백엔드 작성하는 등 다른 작업하고 있다가, 리뷰 도착하면 리뷰에 따라서 수정작업한 뒤 버전컨트롤 시스템에 CL을 서브밋한다.

이제 누가 이 파일들을 변경하든 구글의 테스트 자동화 시스템이 addurl_frontend_test를 수행해서 새로운 변경 사항들이 기존 테스트를 깨는지 검사해준다!

## 테스트 수행

테스트 코드는 개발 속도를 가속화시키고 개발을 방해하지 않는 선에서 실행할 수 있을 때 의미가 있다. 개발 프로세스와 통합되어야 한다!

컴파일, 실행, 분석, 저장, 테스트 보고를 할 수 있는 공통의 인프라스트럭처로 발전시켜 만들어야 함. 필요한 곳에서 문제를 줄여줘야 함. 테스트 코드를 기능 코드와 동일하게 다뤄야한다.

SET가 새로운 테스트 프로그램을 작성한 후 작성한 테스트의 빌드 명세를 구글 빌드 인프라스트럭처에 생성한다. 코드와 빌드 명세가 준비되면 구글의 인프라에서 알아서 자동화 테스트 수행하고 결과 알려준다.

## 테스트 크기 정의

### 소형 테스트

하나의 클래스나 관련 함수로 이뤄진 작은 단위. 외부 의존성 없어야 함.

파일 시스템, 네트워크, 데이터베이스 같은 외부 서비스는 mock이나 fake가 되어야 한다.

외부 의존성이 없으므로 매우 빠르게 자주 수행할 수 있고, 그러므로 더 빠르게 버그를 찾을 수 있다.

일반적으로 개발자들이 소형 테스트 수행하면서 기능 코드를 수정한다. 그리고 코드에 대한 소형 테스트도 개발자가 유지관리한다.

### 중형 테스트

여러 개의 모듈을 다룸. 외부 데이터 소스를 포함할 수 있음.

제한된 모듈의 부분집합들 간의 상호작용을 테스트. 구글 외부에서는 통합테스트라고 부르기도 한다.

일반적으로 SET가 중형 테스트를 구성하고 수행한다. 소형 테스트처럼 자주 수행하지는 않음.

### 대형 테스트, 초대형 테스트

구글 외부에서는 시스템 테스트, 엔드 투 엔드 테스트라고 한다.

전체적인 작업 관점에서 애플리케이션을 검증한다. UI부터 말단 데이터 저장소까지 모든 서브시스템의 동작을 검사. 데이터베이스, 파일 시스템, 네트워크 서비스 등 외부 자원 사용.

## 공유 인프라스트럭처에서 테스트 크기 사용

구글 테스트 수행 인프라스트럭처에서 공유하는 공통의 작업들은 다음과 같다.

- 개발자는 프로젝트에 대한 모든 소형 테스트를 수행해야 하고 그 결과를 즉시 확인할 수 있다.
- 변경 부분에 대해서만 테스트를 수행하고 그 결과를 즉시 확인할 수 있다.
- 엔지니어는 프로젝트에 대한 코드 커버리지를 모을 수 있어야 하고 그 결과를 볼 수 있다.
- 팀은 서브밋된 모든 CL에 대해 프로젝트의 소형 테스트를 모두 수행할 수 있고 리뷰를 위해 팀 내에 그 결과를 분산시켜 보낼 수 있다.
- 팀은 CL이 버전 컨트롤 시스템에 커밋된 이후에 프로젝트에 댛나 모든 테스트를 수행할 수 있다.
- 팀은 주 단위로 코드 커버리지 결과를 모을 수 있고 시간에 따른 진척 상황을 추적할 수 있다.

정확한 테스트 크기가 정해져있기 때문에, 구글의 테스트 수행 시스템은 테스트 일정을 스마트하게 결정할 수 있다!

### 테스트 크기에 따른 이점

소형 테스트는 더 나은 코드 품질을 갖게 하고 훌륭한 예외 처리와 에러 보고를 하게 한다.

대형 테스트는 전체 제품의 품질과 데이터에 대한 검증이 가능하게 한다.

잘 섞어서 쓰는 것이 중요하다!

코드 커버리지(테스트 되는 코드 범위인가?)에 따라서 각 크기별 테스트가 잘 되고 있는지 확인할 수 있다. 소형은 100%인데 중형 대형은 20%라 하면 중형 대형을 더 많이 해야 하고...

구글 엔지니어는 빌드 때 사용한 툴과 동일한 툴을 사용해서 커버리지 보고서를 생성하고 확인할 수 있다. 커맨드라인에서 수행할 수도 있음.

소형 70 중형 20 대형 10 비율로 많이 함. 프로젝트 특성마다 비중은 달라지기는 하지만

하비스터: 프로젝트의 모든 CL을 추적해 시각적으로 보여주는 툴. 테스트 커버리지를 모니터링하는 데 쓰는 또다른 툴이다.

## 테스트 수행에 대한 요구사항

- 각 테스트는 다른 테스트와 독립적이어야 한다.
- 테스트가 시작할 때 그 상태로 남겨져야 하고 다른 부수효과가 있으면 안 된다.

(예를 들어서 JUnit으로 테스트 케이스 쓸 때 CRUD 각자 테스트 케이스 만든 적이 있음. 이 경우에는 D는 C 전에 실행될 수 없으니 독립적이지 않고, C 때문에 DB에 데이터가 남아있으므로 부수효과가 있다.)

데이터 파일을 저장하거나 환경 정보 설정 정보 설정하면서 이 요구사항 위배할수도 있음. 하지만 구글의 테스트 수행환경은 기준이 준수되는지 확인할 수 있다.

독립적이어야 한다는 건 순서 상관도 없어야 하지만 동시에도 돌아갈 수 있어야 한다는 것. 시스템 자원을 둘 중 하나가 배타적으로 접근해야 한다면 나머지가 실패할 것이다. 플래그를 설정하거나 재작성해야 한다.

테스트 백과사전: 테스트 수행 환경을 될 수 있는 한 철저하게 문서화해 기록한 것. 플랫폼이 워낙 잘 만들어져 있다보니 대부분 읽을 필요성을 느끼기보다는 일하면서 배우게 된다

## 테스트 인증

팀이 테스트 얼마나 잘 하는지에 따라 인증 뱃지를 준다!

회사 내에서 각 팀에게 테스트 수준 인증을 해주는 것. 레벨을 많이 올리면 테스트 자원을 많이 받을 수 있고, 낮은 레벨이라면 어떤 팀 레벨이 높은가 보고 배울 수 있고

인터뷰 발췌:

```
저자들: 적용을 위해 초기 설정을 할 때 팀이 극복해야 할 장애물에는 어떤 것들이 있을까요?
닐: 무력증이요. 나쁜 테스트를 갖고 있거나, 테스트가 아예 없거나, 시간이 오래 걸린다는 걱정들이죠. 테스트를 다른 사람의 문제로 보고, 다른 개발자나 테스트 팀의 일이라고 생각하는 거죠.
```

**구글러들은 문제가 해결될 때까지 괴로워하지 않고 모든 것에 대해 궁금증을 가져야 한다.**

